---
title: "DEqMS R Markdown vignettes"
author: 
- name: Yafeng Zhu
  affiliation: Karolinska Institute, Stockholm, Sweden
- name: Lukas Orre
  affiliation: Karolinska Institute, Stockholm, Sweden
- name: Georgios Mermelekas
  affiliation: Karolinska Institute, Stockholm, Sweden
- name: Henrik Johansson
  affiliation: Karolinska Institute, Stockholm, Sweden
- name: Alina Malyutina
  affiliation: University of Helsinki, Helsinki, Finland
- name: Simon Anders
  affiliation: Heidelberg University (ZMBH), Heidelberg, Germany
- name: Janne LehtiÃ¶
  affiliation: Karolinska Institute, Stockholm, Sweden
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc_fload: true
  BiocStyle::pdf_document: default   
package: DEqMS
abstract:
  Instructions to perform differential protein expression analysis using DEqMS
vignette: >
    %\VignetteIndexEntry{DEqMS R Markdown vignettes}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

# Overview of DEqMS

`DEqMS` builds on top of `Limma`, a widely-used R package for microarray data 
analysis (Smyth G. et al 2004), and improves it with mass spectrometry specific 
data properties, accounting for variance dependence on the number of quantified 
peptides or PSMs for statistical testing of differential protein expression. 

# Load the package

```{r Loadpackage}
library(DEqMS)
```

# Differential protein expression analysis
## Example Dataset 1
We analyzed a protemoics dataset (TMT10plex labelled) in which A431 cells 
(human epidermoid carcinoma cell line) were treated with three different miRNA 
mimics (Yan Z. et al. Oncogene 2016). The raw MS data was searched with MS-GF+ 
(Kim et al Nat Communications 2016) and post processed with Percolator (Kall L. 
et al Nat Method 2007). A tabular text output of PSM intensity table filtered 
at 1% peptide level FDR is used as input for downstream analysis.

## Loading the data and preprocess
Read a tabular input in which PSMs are in rows and samples are in columns.
Intenisty values were log2 transformed since systematic effects and variance 
components are usually assumed to be additive on log scale (Oberg AL. et al 
JPR 2008; Hill EG. et al JPR 2008).
```{r retrieveExampleData, message=FALSE}
### retrieve example dataset
library(ExperimentHub)
eh = ExperimentHub()
query(eh, "DEqMS")
dat.psm = eh[["EH1663"]]
```

```{r log2transform}
dat.psm.log = dat.psm
dat.psm.log[,3:12] =  log2(dat.psm[,3:12])
head(dat.psm.log)
```
Generate sample annotation table.
```{r,design}
cond = c("ctrl","miR191","miR372","miR519","ctrl",
"miR372","miR519","ctrl","miR191","miR372")

sampleTable <- data.frame(
row.names = colnames(dat.psm)[3:12],
cond = as.factor(cond))
sampleTable
```

## Generate a summary of the data
Since each row is one PSM, to count how many PSMs per protein, we simply use 
function `table` in R to count the number of occurance that each protein ID 
appears.
```{r PSMdistribution}
psm.count.table = as.data.frame(table(dat.psm$gene))
rownames(psm.count.table)=psm.count.table$Var1

plot(sort(log2(psm.count.table$Freq)),pch=".",
    xlab="Proteins ordered by PSM count",ylab="log2(PSM count)")
```

## Summarization and Normalization
Here, median sweeping is used to summarize PSMs intensities to protein log2 
ratios. In this procedure, we substract the spectrum log2 intensity from the 
median log2 intensities of all samples. The relative abundance estimate for 
each protein is calculated as the median over all PSMs belonging to this 
protein.(Herbrich et al JPR 2012 and D'Angelo et al JPR 2016)
Assume the log2 intensity of PSM `i` in sample `j` is $y_{i,j}$, its relative 
log2 intensity of PSM `i` in sample `j` is $y'_{i,j}$: 
$$y'_{i,j} = y_{i,j} - median_{j'\in ctrl}\ y_{i,j'} $$
Relative abundance of protein `k` in sample `j` $Y_{k,j}$ is calculated as:
$$Y_{k,j} = median_{i\in protein\ k}\ y'_{i,j} $$

Correction for differences in amounts of material loaded in the channels 
is then done by subtracting the channel median from the relative abundance 
(log2 ratio), normalizing all channels to have median zero.
```{r boxplot}
dat.gene.nm = medianSweeping(dat.psm.log,group_col = 2)

boxplot(dat.gene.nm,xlab="TMT 10 channels",
        ylab="log2 relative protein abundance")
```

## DEqMS analysis
Limma assumes equal prior variance for all genes, the function 
`spectraCounteBayes` in DEqMS package is able to correct the biase of prior 
variance estimate for proteins quantified by different number of PSMs. It works 
in a similar way to the intensity-based hierarchical Bayes method
(Maureen A. Sartor et al BMC Bioinformatics 2006).
Outputs of `spectraCounteBayes`:  
object is augmented form of "fit" object from `eBayes` in Limma, with the 
additions being:
`sca.t` - Spectra Count Adjusted posterior t-value  
`sca.p` - Spectra Count Adjusted posterior p-value  
`sca.dfprior` - DEqMS estimated prior degrees of freedom  
`sca.priorvar`- DEqMS estimated prior variance
`sca.postvar` - DEqMS estimated posterior variance
`model` - fitted model

```{r DEqMS}
gene.matrix = as.matrix(dat.gene.nm)
colnames(gene.matrix) = as.character(sampleTable$cond)
design = model.matrix(~cond,sampleTable)

fit1 <- lmFit(gene.matrix,design)
fit2 <- eBayes(fit1) # Limma analysis

fit2$count = psm.count.table[rownames(fit2$coefficients),]$Freq
fit3 = spectraCounteBayes(fit2)
DEqMS.results = outputResult(fit3,coef_col = 3) # extract DEqMS results
head(DEqMS.results)
```

Generate variance ~ PMS count boxplot, check if the DEqMS correctly find the relation between prior variance and PSM count
```{r PriorVarianceTrend}
VarianceBoxplot(fit3,n=20, xlab="PSM count") # n=20 plot only genes with PSM count <=20
```

# Comparing DEqMS to Limma
## Compare prior variance and posterior variance in Limma and DEqMS

Visualize the prior variance estimated from DEqMS and Limma
```{r PriorVar}
VarianceScatterplot(fit3, xlab="log2(PSM count)")
limma.prior = fit3$s2.prior
abline(h = log(limma.prior),col="green",lwd=3 )
legend("topright",legend=c("DEqMS prior variance","Limma prior variance"),
        col=c("red","green"),lwd=3)
```

Generate residual plot to evaluate the fit model in DEqMS
```{r DEqMSResidualplot}
Residualplot(fit3,  xlab="log2(PSM count)",main="DEqMS")
```

Make the same plot for Limma
```{r LimmaResidualplot}
x = fit3$count
y = log(limma.prior) - log(fit3$sigma^2)
plot(log2(x),y,ylim=c(-6,2),ylab="Variance(estimated-observed)", pch=20, cex=0.5,
     xlab = "log2(PSMcount)",main="Limma")
```     

Visualize the change of posterior variance after PSM count adjustment. 
The plot here shows posterior variance of proteins "shrink" toward the 
fitted value to different extent depending on PSM number. 
```{r PostVar, echo=TRUE, fig.height=5, fig.width=10}
x = fit3$count
y = fit3$s2.post # Limma posterior variance

op <- par(mfrow=c(1,2), mar=c(4,4,4,1), oma=c(0.5,0.5,0.5,0))
plot(log2(x),log(y),pch=20, cex=0.5, xlab = "log2(PSMcount)", 
    ylab="log(Variance)",
    main="Posterior Variance in Limma")

y = fit3$sca.postvar # DEqMS posterior variance
plot(log2(x),log(y),pch=20,cex=0.5, xlab = "log2(PSMcount)",
    ylab="log(Variance)", 
    main="Posterior Variance in DEqMS")
```

## Compare p-values from DEqMS to ordinary t-test, anova and Limma
We first apply t.test to detect significant protein changes between ctrl 
samples and miR372 treated samples, both have three replicates.

## T-test analysis
```{r t-test}
pval.372 = apply(dat.gene.nm, 1, function(x) 
t.test(as.numeric(x[c(1,5,8)]), as.numeric(x[c(3,6,10)]))$p.value)

logFC.372 = rowMeans(dat.gene.nm[,c(3,6,10)])-rowMeans(dat.gene.nm[,c(1,5,8)])
```

Generate a data.frame of t.test results, add PSM count values and order the 
table by p-value.
```{r,echo=TRUE}
ttest.results = data.frame(gene=rownames(dat.gene.nm),
                    logFC=logFC.372,P.Value = pval.372, 
                    adj.pval = p.adjust(pval.372,method = "BH")) 

ttest.results$PSMcount = psm.count.table[ttest.results$gene,]$Freq
ttest.results = ttest.results[with(ttest.results, order(P.Value)), ]
head(ttest.results)
```

## Anova analysis
Anova analysis is equivalent to linear model analysis. The difference to 
Limma analysis is that estimated variance is not moderated using empirical 
bayesian approach as it is done in Limma.

```{r Anova}
ord.t = fit1$coefficients[, 3]/fit1$sigma/fit1$stdev.unscaled[, 3]
ord.p = 2*pt(abs(ord.t), fit1$df.residual, lower.tail = FALSE)
ord.q = p.adjust(ord.p,method = "BH")
anova.results = data.frame(gene=names(fit1$sigma),
                            logFC=fit1$coefficients[,3],
                            t=ord.t, 
                            P.Value=ord.p, 
                            adj.P.Val = ord.q)

anova.results$PSMcount = psm.count.table[anova.results$gene,]$Freq
anova.results = anova.results[with(anova.results,order(P.Value)),]

head(anova.results)
```

## Extract Limma result
Extract limma results using `topTable` function,  `coef = 3` allows you to 
extract the contrast of specific condition (miR372), option `n= Inf` output 
all rows. Add PSM count values in the table.
```{r,echo=TRUE}
limma.results = topTable(fit2,coef = 3,n= Inf)
limma.results$gene = rownames(limma.results)
limma.results$PSMcount = psm.count.table[limma.results$gene,]$Freq

head(limma.results)
```

## Comparing p-values by different analysis.
plotting top 500 genes ranked by p-values.
```{r pvalue}
plot(sort(-log10(limma.results$P.Value),decreasing = TRUE)[1:500], 
    type="l",lty=2,lwd=2, ylab="-log10(p-value)",
    xlab="Proteins ranked by p-values",
    col="purple")
lines(sort(-log10(DEqMS.results$sca.P.Value),decreasing = TRUE)[1:500], 
        lty=1,lwd=2,col="red")
lines(sort(-log10(anova.results$P.Value),decreasing = TRUE)[1:500], 
        lty=2,lwd=2,col="blue")
lines(sort(-log10(ttest.results$P.Value),decreasing = TRUE)[1:500], 
        lty=2,lwd=2,col="orange")
legend("topright",legend = c("Limma","DEqMS","Anova","t.test"),
        col = c("purple","red","blue","orange"),lty=c(2,1,2,2),lwd=2)
```


# Visualization of the results

## PSM/Peptide profile plot
`peptideProfilePlot` function will plot log2 intensity of each PSM/peptide of 
the protein in the input table.
```{r PSMintensity}
library(ggplot2)
dat.psm.log.ordered = dat.psm.log[,c("Peptide","gene",
                                    sort(colnames(dat.psm.log)[3:12]))]
peptideProfilePlot(dat=dat.psm.log.ordered,col=2,gene="TGFBR2")
```

## Volcano plot
```{r volcanoplot1}
library(ggrepel)

# if you wish plot adjusted p-values by BH method on y-axis
DEqMS.results$log.adj.pval = -log10(DEqMS.results$sca.adj.pval) 
ggplot(DEqMS.results, aes(x = logFC, y = log.adj.pval)) + 
    geom_point(size=0.5 )+
    theme_bw(base_size = 16) + # change theme
    xlab(expression("log2 miR372/ctrl")) + # x-axis label
    ylab(expression(" -log10 adj.pval")) + # y-axis label
    geom_vline(xintercept = c(-1,1), colour = "red") + # Add fold change cutoffs
    geom_hline(yintercept = 2, colour = "red") + # Add significance cutoffs
    geom_vline(xintercept = 0, colour = "black") + # Add 0 lines
    scale_colour_gradient(low = "black", high = "black", guide = FALSE)+
    geom_text_repel(data=subset(DEqMS.results, abs(logFC)>1&log.adj.pval> 2),
                    aes( logFC, log.adj.pval ,label=gene)) # add gene label

```

you can also use `volcanoplot` function from Limma. However, it uses `p.value`
from Limma. If you want to plot `sca.pvalue` from `DEqMS`, you need to modify
the fit object. (original p-values are plotted here)

```{r volcanoplot2}
fit3$Limma.p.value = fit3$p.value # keep Limma p.value before replacing it
fit3$p.value = fit3$sca.p # replace Limma p.value with DEqMS p.value
volcanoplot(fit3, coef=3, style = "p-value", highlight = 20,
            names=rownames(fit3$coefficients))
```

## PCA plot
```{r PCAplot}
library( RColorBrewer )
pr <- prcomp(t(gene.matrix)) 
plot( pr$x[,1:2], asp=1, col=brewer.pal(4,"Set1")[sampleTable$cond], pch=17)
text( pr$x[,1], pr$x[,2]-1, label=as.character(sampleTable$cond))
legend( "bottomright", legend = levels( sampleTable$cond ), 
    col = brewer.pal(4,"Set1"), pch=17 )
```

## Sample correlation heatmaps
plot sample correlation heatmap
```{r heatmap1}
library( pheatmap )
cm <- cor( gene.matrix )
# rearrange columns so that same sample types are together
cm.order = cm[order(colnames(cm)),order(colnames(cm))]

pheatmap(cm.order,
    cluster_rows=FALSE, cluster_cols=FALSE,
    color = colorRampPalette(c("blue", "white", "red"))(100))
```


or plot Eucldiean distance heatmap
```{r heatmap2}
dm <- as.matrix( dist( t( gene.matrix ) ))
dm.order = dm[order(colnames(cm)),order(colnames(cm))]
pheatmap(dm.order,
    cluster_rows=FALSE, cluster_cols=FALSE,
    color = colorRampPalette(c("red", "white"))(100))

```
